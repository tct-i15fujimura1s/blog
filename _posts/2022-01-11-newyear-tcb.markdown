---
layout: post
title:  "新春TCB2022"
date:   2022-01-11 08:53:00 +0900
categories: jekyll update
tags:
- TechFUL
- TCB
---

概ね楽しかったです。

## 1/1 年越し直後

年越しをした後、TCBがあったことを思い出したので最初の4問を解きました。

### 「2022 sequence」

「2022」の個数を数える問題です。$|S|-3$回ループして数えました。

所要時間は50秒でした。

### 「Quote」

ダブルクォートとシングルクォートの個数をそれぞれ数え、ダブルクォートの個数は2倍して足しました。

所要時間は43秒でした。

### 「あけおめ」

簡単な動的計画法です。ABC211Cの判定版とも言えそうです。1通り以上「akom」が取れるならYesです。

所要時間は1分42秒でした。

### 「2022のような数」

harshad数の判定は高速にできるはずなので、iをLからRまで回してそれぞれ数えました。
仮に$N$から$N+4$までではなく、$N+M$までがすべてharshad数であるという条件でも、先にharshad数判定をして累積和を使うことでできそうです。

所要時間は3分28秒でした。

## 1/1 昼

異常に早起きしてしまって体調が悪かったので、午前中はTCBをするのを控えていました。
体調がよくなってきた昼からTCBを再開しました。

### 「何時になったら出られる？」

それぞれの人について順番に、前の人が降りてからどれだけの時間がかかるかを考えました。
前の人が降りた地点を$x$、今の人が降りる地点を$y$とすると、$x\le y$なら$y-x$だけかかり、$y \lt x$なら次の周回まで（$N - x + y$）かかります。まとめると$(y - x)\% M$になります。
隣り合う人の差ということになるので、計算を楽にするために、便宜的に、最初に地点1で降りる人がいたということにしました。

所要時間は2分31秒でした。

### 「多みくじ」

ここから難しくなってきたように感じます。特に、場合の数は苦手で…。

赤い玉がA個、青い玉がB個あるうちからK個の玉を取り出したとき、赤い玉の個数の期待値を求める問題です。
$0 \le i \le \min(A, K)$のそれぞれについて、（$i\times$赤い玉が$i$個含まれる確率）の総和を求めると期待値が計算できます。赤い玉が$i$個含まれる確率は、$A$個から$i$個選び、$B$個から$K-i$個選んだ場合の数を$A+B$個から$K$個選んだ場合の数で割れば出ます。

$$
\sum_{i=0}^{\min(A,K)} i \times \frac{{_A}C{_i}\times{_B}C{_{K-i}}}{{_{A+B}C{_K}}}
$$

所要時間は34分53秒でした。

### 「Make Unique」

多重集合から要素を$K$個取り除いて、重複を除去したとき、結果が何通りあるかという問題です。
また場合の数か…と思ったものの、制約を見ればビット全探索が可能だったのでほっとしました。

それぞれの値について、削除するか残すかのパターンを考えます。

- $i$を削除したい場合は、$A_i$個の要素を必ず消す必要があります。
- 逆に、$i$を残したい場合は、消してもいいのは$A_i-1$個までです。

必ず消す要素の個数が$K$以下であり、かつ、必ず消す要素と消してもいい要素の個数の合計が$K$以上であるなら、そのパターンを達成できます。

所要時間は7分19秒でした。

### 「Mex Sum」

この問題は解けませんでした。

前問が得意系の問題だったので、調子に乗って次の問題を開きました。

1以上M以下の整数からなる単調非減少な長さNの数列すべてに対するmexの合計を求めよという問題でした。しかし、どうすればいいのか…。

まず考えたのが、差分を取ることです。例えば、数列が$[1, 2, 3]$なら、差分は$[1,1,1]$になります。差分を取ると、差分の総和はM以下ということになります。

その後いろいろ試行錯誤をしましたが、残念ながら答えは出てきませんでした。途中でスターリング数とか二項係数などが出てきましたが、高速に計算する方法もわからず。後で見るとどうやらスターリング数は使わないようでした。すこし悔しいので、後で解き直してみたいです。

# 1/5

ずっと「Mex Sum」について考えていましたが、いっこうに進まないので半ばあきらめて次の問題に進むことにしました。

### 「Domino Tiling」

典型的な二部マッチングの問題でした。ドミノを置くことは、二つの隣り合うマスの間に容量1のフローが流れていることと見ることができます。上下の辺は、どちらも`V`または`.`が書かれているときにつなぐことができ、左右の辺はどちらも`H`または`.`が書かれているときにつなぐことができます。グリッドをチェス盤のように黒と白に塗り分け、ソースから黒に、黒から白に、白からシンクにと辺をつけます。最大フローを計算するために、AtCoder Libraryを利用しました。

所要時間は28分48秒でした。

# 1/6

逆転チャンス問題が追加されました。

### 「01-prefix」

なぜか忘れましたが、最初に01-prefixを解きました。ビット列がいくつか与えられて、それらの空でない部分集合のLCS長の総和を求める問題でした。

見た瞬間、「これはTechFULでよく出るBinary Trie問題かもしれない…」と思いました。しかしBinary Trieの使い方がわからないので、別の解き方を探すことにしました。

まずは、Trie木のようにグラフを作ってみることにします。以下はサンプルケース1に対応する図です。

![サンプルケース1の図](https://user-images.githubusercontent.com/44060475/150279359-ff0d1f8d-1ceb-45fe-8425-b2c53d071f5f.png)

これをどうにか（おそらく葉から根に向かっての動的計画法など）することで、うまく答えを得ようと考えました。それぞれの頂点に通る回数を置いてみたり、サンプルケース以外の図も描いてみたり、いろいろと試行錯誤をすると、見えてきたことがありました。どうやら、今いる頂点にビット列の端点や枝分かれがあるときはその長さのLCSを考えることができそうです。

最終的に、それぞれの頂点について、`(答え, 個数)`を持つことにしました。さかのぼっていく過程で、次のようにしました。（うまく整理できていないですが。）

- 基本的に、答えは二つの枝の和である。
- 枝分かれがある場合は、LCS長が現在の深さで、個数が両方の枝にある個数の積であるようなLCSを加える。
- 現在の頂点に端点がある場合は、端点と枝を両方含むLCSや、端点にあるビット列を二つ以上含むLCSを加える。

サンプルケース1

![サンプルケース1の図](https://user-images.githubusercontent.com/44060475/150280371-5bb80de1-e7df-47d6-aa35-95969ce1fe19.png)

サンプルケース2

![サンプルケース2の図]()