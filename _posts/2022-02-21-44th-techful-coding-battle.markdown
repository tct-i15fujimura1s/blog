---
layout: post
title:  "第44回TechFUL Coding Battle「データ処理」"
date:   2022-02-21 00:00:00 +0900
categories: jekyll update
tags:
- TechFUL
- TCB
---

# 「バーナム暗号」

XOR をしろという問題のようです。ことはそう複雑ではなさそうだったので、まずは$C\text{\textasciicircum}B$を出力してみました。テストして結果が合うことを確認し、提出。もちろん正解でした。

所要時間は50秒でした。

# 「第一n分位数」

問題名からこれを求めるんだろうなというのが分かっていたので、求める方法を検索しました。しかし、求める記事が出てこない……。検索力が低いのかもしれません。問題を開くと、ちょうど求める方法が書いてあったため、そのまま実装しました。歩きながらコーディングしたので時間がかかってしまいました。

所要時間は5分40秒でした。

# 「どっちを向く？」

Techくんの動きをよく観察すると、左のゴミの量が右のゴミの量以上場合には、最後は正の向きへ進み、そうでなければ負の向きへ進むことがわかります。とはいえ、同じ場合について間違えたくなかったので、あるていどシミュレーションしました。

もっとも直接的なシミュレーションは、Techくんの位置と座標を考えて動きをそのままシミュレートすることだと思います。問題の制約的にはこれでも間に合いそうですが、これでは実装が複雑になってしまうので、最初の位置よりも左にあるゴミと右にあるゴミをそれぞれ数えて、右、左、右、左と取っていくことにしました。とはいっても、これなら同じ場合どうなるかをしっかり考えて数だけ比較したほうが早かったかもしれません。

所要時間は2分46秒でした。

# 「派手な数列」

数列の分散のことを派手さと呼んでいるようです。

分散をそのまま求めてもいいですが、もしかすると誤差で不正解になるかもしれないので、大小関係はそのまま整数にして求めることにしました。

```math
\frac{1}{N} \sum_{i=1}^{N} (X_i - \bar{X})^2 \to \sum_{i=1}^{N} (N X_i - N \bar{X})^2
```

このように式を変形すると、かならず整数になります。$N\bar X$は$A_i$の総和です。しかも、$N^3$を掛けただけなので結果の大小は変わりません。

所要時間は2分26秒でした。

# 「Min of Mod」

$(A_j + X_i) \% M$ の最大値を高速に求めよという問題です。$A_j$と$X_i$を$M$で割ったあまりに置き換えても答えは変わらないので、$A'_j = A_j \% M, X'_i = X_i \% M$に対して$(A'_j + X'_i) \% M$を求める問題ということにしてしまいます。

$A'_j + X'_i$と$M$の大小関係について考えると、$A'_j + X'_i < M$のときは$(A'_j + X'_i) \% M = A'_j + X'_i$になります。しかし、$A'_j + X'_i \ge M$のときは$(A'_j + X'_i) \% M = A'_j + X'_i - M$になります。こう考えると、$A'_j$のうち、最小値と、$M - X'_i$以上のもの（あれば）についてそれぞれ$(A'_j + X'_i) \% M$を計算して、小さい方を答えればよさそうとわかります。

所要時間は5分11秒でした。

# 「貪欲法の辞書」

非常に苦戦して、正答するまで15時間かかりました。

まず、問題文に書いてあるとおり？に処理する場合を考えてみました。これは$i=1,2,\ldots,Q$について、$S_{a_i}$をもとの位置から取り出して先頭に挿入することと同じです。これをそのまますると$O(NQ)$になるため、どう工夫するべきか考えました。

- キューを使う：キューを使うと先頭への挿入は$O(1)$でできますが、途中から取り出す操作は$O(N)$かかってしまうため、$O(NQ)$よりも小さくはなりません。
- 線形リストを使う：途中から$O(1)$で取り出せますが、$S_{a_i}$が何番目にあったかを知るには$O(N)$かかってしまうため、$O(NQ)$よりも小さくはなりません。
- 遅延セグメント木で区間加算？：要素が何番目にあるかを遅延セグメント木で管理できないか考えました。操作をすることは$S_{a_i}$より前にあった要素の順番をすべて$+1$することと同じです。しかし、途中から順番がごちゃごちゃになるため、少ない回数の区間加算によって実現することは困難です。
- `set`で要素の位置を管理し、`set.lower_bound(x) - set.begin()`で何番目か取得する：ランダムアクセスイテレータではないため、このやり方では取得できず、さらに、`distance(set.begin(), set.lower_bound(x))`を使うと$O(N)$かかってしまいました。
- フェニック木を使って要素の位置を管理する：このやり方でいけました。長さ$N+Q$のフェニック木を作り、要素の位置を$Q$個右にずらして入れておきます。$S_{a_i}$より前の要素の個数を知るには、それより前の区間和を取ります。操作ごとに、$Q-1, Q-2, \ldots, 0$と前の方に前の方に入れることで先頭への挿入を実現できました。

コードにすると非常に短いものでしたが、試行錯誤が大変でした。

所要時間は15時間5分33秒、2回誤答をして、失点40でした。

# 「Inconvenient City」

それぞれのコンビニについて、使う場合と使わない場合を考え、全通りについて、それぞれの家の最寄りのコンビニからの距離を計算しました。ここで幅優先探索をしてしまったのですが、おそらく幅優先探索はしなくてもよかったと思います。とはいえ、オーダーレベルでの悪化はしていないです。それぞれの家について最寄りのコンビニへの距離の二次元の累積和を取りました。各クエリに対しては、クエリの範囲内に含まれるコンビニの組合せに対応するものを返しました。

所要時間は26分20秒、失点12でした。

# 「退屈なデータ処理はロボットにやらせよう」

クエリ$t_i=2$が来た時、処理時間が短い順に$x_i$個のロボットを使うと答えが求まります。このとき、求めるべきは小さい方から$x_i$番目の処理時間と、$x_i$番目までの処理時間の合計です。これがなかなか曲者でした。フェニック木を二本植え、それぞれに処理時間に対してのロボットの個数と、処理時間の総和を管理させました。$x_i$番目の処理時間や、$x_i$番目よりも処理時間が短いものの総和は簡単に求めることができます。$x_i$番目と同じ処理時間のものの総和は、$x_i$からそれより処理時間が短いロボットの個数を引き、$x_i$番目の処理時間を掛けることで求まります。頭がうまく働いていなかったため、実際にはそれほど複雑ではないですが、長い時間をかけてしまいました。

所要時間は1時間5分48秒、失点51でした。

# 「x + 2^a y = 0」

あまりやりたくない、数学的な見た目をしていましたが、蓋をあけてみるとデータ構造問題でした。

$x_p + 2^a x_q = 0$という式からはふたつのことが読み取れます。

- $\|x_p\| = 2^a \|x_q\|$であること。
- $x_p$と$x_q$の符号が異なること。

この二つのうちどちらかに矛盾？が生じると、$x_p = x_q = 0$となって自由度が$0$になります。また、矛盾していなくても、式でつながれている変数は自由度が$1$になります。これらの条件を別々に重み付きUnionFindで管理しました。
難しかったのが自由度が$0$になったグループと別のグループを結合したときです。どちらも自由度が$0$なら全体の自由度は変化しませんが、片方の自由度が$1$以上なら全体の自由度はひとつ減ります。

所要時間は32分43秒、失点12でした。

# 「部分回文」

面白そうな見た目をしていますが、時間が足りなくて深く考えることはできませんでした。おそらく、Dequeと、Manacherのアルゴリズムの変形と、累積和などを使うとできるのではないかと思います。ある点を中心とする回文の個数はその点を中心とする最長の回文の半径に等しいということが使えそうでした。
時間がないのでとりあえずそのままの解法を提出しました。

採点対象の提出までの所要時間2分8秒、失点60でした。