---
layout: post
title:  "TechFULプラクティス問題「Prefix Suffix Substring」"
date:   2021-11-16 13:30:00 +0900
categories: jekyll update
tags:
- TechFUL
- TechFUL難易度6
- プラクティス問題
- アルゴリズム
- 文字列アルゴリズム
---

$S$ の部分文字列のうち、 `/A.{,K}B/` という形式になっているものの個数を求める問題です。

[「Prefix Suffix Substring」](https://techful-programming.com/user/practice/problem/coding/12845)

## 考えたこと

まず、 $S$ の中に $A, B$ が出現する位置を求めたくなりますが、初っ端から大きな問題が立ちはだかります。 $S$ の中から $A$ を検索するには、二重ループを使えばいいですが、それだと最悪で $O(\vert S\vert \vert A\vert)$ 時間がかかります。この問題の制約だと明らかにそれでは間に合わないので、別の方法を考えます。

ここでカテゴリの「文字列アルゴリズム」という言葉をヒントにすると、どうすればいいかわかりました。長い文字列を検索する良いアルゴリズムは？探してみると、[いろいろ](https://ja.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%88%97%E6%8E%A2%E7%B4%A2)ありました。

- クヌース-モリス-プラット法
- ボイヤー-ムーア法
- Quick Search法
- エイホ-コラシック法
- ラビン-カープ法
- Bitapアルゴリズム

これらのうち、最悪計算量でも間に合いそうなものは、**クヌース-モリス-プラット法**、**ボイヤ-ムーア法+ガリル規則**、**エイホ-コラシック法**でした。**Quick Search法**と**ラビン-カープ法**は入力によっては最悪計算量が $O(\vert S\vert \vert A\vert )$ になり、また、**Bitapアルゴリズム**は計算量がよくわからなかったので選びませんでした。

Wikipediaを見ると、[**クヌース-モリス-プラット法**（KMP法）](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%8C%E3%83%BC%E3%82%B9%E2%80%93%E3%83%A2%E3%83%AA%E3%82%B9%E2%80%93%E3%83%97%E3%83%A9%E3%83%83%E3%83%88%E6%B3%95)が最も実装しやすそうだったので、これを選ぶことにします。KMP法では、まず検索する文字列から「部分マッチ」テーブルを作ります。このテーブルの$i$番目の要素は、検索する文字列の先頭$i$文字の接頭辞と接尾辞が最大で何文字一致するかを示しています。このテーブルをうまく使うことで、線形時間で文字列検索をすることができます。実装にあたってはWikipediaの他に[文字列の頭良い感じの線形アルゴリズムたち - あなたは嘘つきですかと聞かれたら「YES」と答えるブログ](https://snuke.hatenablog.com/entry/2014/12/01/235807)を参考にしました。


```python
# S: 検索する対象
# W: 検索する文字列
# 返り値: S の中の W の位置の配列
def kmp_search_all(S, W):
  m = 0
  i = 0
  T = kmp_table(W)
  indices = []
  while m + i < len(S):
    if W[i] == S[m + i]:
      i += 1
      if i == len(W):
        indices.append(m)
        m += i - T[i]
        if i > 0: i = T[i]
    else:
      m += i - T[i]
      if i > 0: i = T[i]
  return indices

# W: 検索する文字列
# 返り値: テーブル
def kmp_table(W):
  T = [0] * (len(W) + 1)
  T[0] = -1
  j = -1
  for i in range(len(W)):
    while j >= 0 and W[i] != W[j]:
      j = T[j]
    j += 1
    T[i + 1] = j
  return T
```

これで $S$ の中に $A$ が現れる位置 $a_i$ と $B$ が現れる位置 $b_i$ がわかりました。

次に、 $a_i + \vert A\vert  \le b_j \le a_i + \vert A\vert + K$ となる $(i, j)$ の組の個数を数える必要があります。$a_i, b_j$はそれぞれ最大$|S|$個になりうるので、うまく数えないとやはり間に合いません。

ここで、累積和を使うことにします。長さ $\vert S\vert $ の配列 $L$ を考え、 $L_{b_j} = 1$ で、それ以外の位置はすべて $0$ ということにします。すると、すべての $i$ についての $L[a_i + \vert A\vert , a_i + \vert A\vert  + K]$ の総和は先で述べた条件を満たす $(i, j)$ の個数と等しくなります。この総和は累積和を使うと $i$ ごとに $O(1)$ 、全体では $O(\vert S\vert )$ で求まるので、この問題を解くことができました。

## コード
```python
# S: 検索する対象
# W: 検索する文字列
# 返り値: S の中の W の位置の配列
def kmp_search_all(S, W):
  m = 0
  i = 0
  T = kmp_table(W)
  indices = []
  while m + i < len(S):
    if W[i] == S[m + i]:
      i += 1
      if i == len(W):
        indices.append(m)
        m += i - T[i]
        if i > 0: i = T[i]
    else:
      m += i - T[i]
      if i > 0: i = T[i]
  return indices

# W: 検索する文字列
# 返り値: テーブル
def kmp_table(W):
  T = [0] * (len(W) + 1)
  T[0] = -1
  j = -1
  for i in range(len(W)):
    while j >= 0 and W[i] != W[j]:
      j = T[j]
    j += 1
    T[i + 1] = j
  return T

S = input()
A, B, K = input().split()
K = int(K)

# インデックスを求める
a = kmp_search_all(S, A)
b = kmp_search_all(S, B)

# 配列 L を作る
L = [0] * len(S)
for b_j in b:
  L[b_j] = 1

# 累積和をとる
L_sum = [0] * (len(S) + 1)
for k in range(len(S)):
  L_sum[k + 1] += L_sum[k] + L[k]

# 答えを求める
ans = 0
for a_i in a:
  r = a_i + len(A) + K
  l = a_i + len(A)
  ans += L_sum[min(r + 1, len(S))] - L_sum[min(l, len(S))]

print(ans)
```