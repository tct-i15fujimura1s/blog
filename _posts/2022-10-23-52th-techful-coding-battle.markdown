---
layout: post
title:  "第52回TechFUL Coding Battle"
date:   2022-10-23 23:55:00 +0900
categories: jekyll update
tags:
- TechFUL
- TCB
---

久しぶりに得意な回でしたが、理論値を出している人が大量に居て負け！

## [techful 型文字列](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22105)

### 問題の概要

文字列 $S$ が与えられます。

- $S$ の接頭辞が `tech` なら `tech` を出力します。
- $S$ の接尾辞が `ful` なら `ful` を出力します。
- 両方なら `techful` を出力します。

### 感想

FizzBuzz 感のある問題でした。

合格まで1分16秒、22/22点。

## [マトリョーシカ文字列](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22077)

### 問題の概要

文字列 $S$ と長さ $2$ の文字列 $l, r$ があるらしいです。

$S \leftarrow l + S + r$ を $1$ 回以上行った後の文字列が与えられるので、 $l + r$ を答えます。

### 感想

一瞬悩んで、両端から $2$ 文字取ってくればよいことに気づきました。

合格まで51秒、22/22点。

## [連立方程式](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22081)

### 問題の概要

長さ $N$ の文字列 $(S_1, S_2)$ に対して、以下の条件を満たす文字列の組 $(T_1, T_2)$ がいくつあるかを数え上げます。

- $|T_1|, |T_2| \gt 0$
- $T_1 + T_2 = S_1$
- $T_2 + T_1 = S_2$

ただし $|s|$ は文字列 $s$ の長さ、 $s + t$ は文字列 $s, t$ の連結です。

### 感想

条件から、$S_1$をどこかで区切って $T_1, T_2$ とし、 $T_2 + T_1 = S_2$ になるか判定すればいいことがわかります。

残念ながら構文ミスを修正しないまま提出してしまったりして、3回も不正解を食らいました。

合格まで提出4回、4分8秒、33/44点。

## [STring](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22106)

### 問題の概要

Sの、隣合う文字が1つ次の文字であるような最長の部分文字列の長さを求めます。

### 感想

ランレングス圧縮と似たような実装をするのが良いと思います。

合格まで4分1秒、44/44点。

## [検索の重複](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22086)

### 問題の概要

文字列が$Q$回与えられるので、それぞれの回について以前同じものが与えられていたか判定します。

### 感想

文字列をsetに入れるだけです。

合格まで1分28秒、66/66点。

## [GuesString](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22104)

### 問題の概要

文字列$S$があり、TechちゃんとFULくんはともに$S$の内容を知っています。

Techちゃんは「右」と「左」からなる、インデックスの動かし方（K回）を決めます。

FULくんはTechちゃんに秘密でインデックスiを決めます。

その後、FULくんはTechちゃんの決めた動かし方に従ってインデックスを動かしていき、そのときの $S_i$ 、もしくは範囲外なら `*` を答えます。

FULくんがどのようにインデックスiを決めてもTechちゃんがiを推測できるためには、Kを最小でいくつにする必要がありますか。

### 感想

Techちゃんの最善の戦略は、インデックスをつねに一方向に動かすことです。
それに対するFULくんの最善の戦略は、 $S$ に同じふたつの文字列 $T$ が含まれるとして、その文字列のうち最長のものの中にインデックスiを置くことです。

このように考えると、Tからインデックスがはみでるとiが推測できるため、 $K = |T|$ とすればよいことがわかります。

合格まで10分7秒、88/88点。

## [Simple LCP Query](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22087)

### 問題の概要

長さ $N$ の文字列 $S$ が与えられます。
$S$ の $i$ 文字目から最後までを $P_i$ とします。

これに対する、「$l \le i \le r$ なる $P_i$ すべての最長共通接頭辞の長さ」というクエリを処理します。

### 感想

まずタイトルを見て、「おっ、文字列アルゴリズムか！？」とACL(AtCoder Library)をエディタに貼り付けたりしていました。
残念ながら、その準備は無駄に終わってしまいましたが。

連続する接尾辞の接頭辞というものを観察すると、おおまかに $l=r$ の場合と $l<r$ の場合が考えられることがわかります。

- $l=r$ の場合：全体が接頭辞となるため、長さは $N-l+1$ です。
- $l<r$ の場合：先頭と異なる文字が来ると、そこで共通接頭辞は成り立たなくなるため、先頭から同じ文字が何文字続いているかです。先頭の文字が異なる接尾辞が含まれれば共通接頭辞の長さは $0$ です。

$S$ をランレングス圧縮してから処理すると $l<r$ の場合も判定しやすくなります。

合格まで4分47秒、110/110点。

## [文字列の反転](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22085)

### 問題の概要

文字列 $S$ を隣接二文字の交換を繰り返すことによって反転したいとき、交換の回数は最小で何回かという問題です。

### 感想

タイトルからは問題が想像し難かったです。問題の内容を正確に表し、かつ表しすぎない良いタイトルだと思いました。

反転したときにどのようにインデックスの順列が変化するかを考え、その順列の転倒数を求めることで解きました。
もしかするとオーバーキルだったかもしれませんが、これが一番考えなくて済み方法だったため・・・。

合格まで提出2回、18分12秒、119/132点。

## [Prefix Match Queries](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22088)

### 問題の概要

$N$ 個の文字列 $S_1〜S_N$ が与えられます。それぞれの文字列にはカウンタがあり、最初はすべて $0$ です。

これに対する次の $Q$ 個のクエリを処理します。

- `1 T X`：$T$ を接頭辞として含む文字列に対して、カウンタに $X$ を加算する。
- `2 P`：$P$ 番目の文字列のカウンタを表示する。

### 感想

「Prefix Match Queries」という問題名から、「はじめに文字列が多数与えられ、クエリでは与えられた接頭辞を含む文字列がいくつあるか答える」という問題を推測したため、問題を開く前にTrie木を書いておきました。
結果はほぼドンピシャで、書いたTrie木の構造に変更をほとんど加えることなく解くことができました。

ほとんどTrie木を実装するだけですが、他にもポイントがあります。例えば、クエリ1を処理するときは、文字列すべてに対して処理するのではなく、接頭辞に対して加算するなど。

採点ボタンを押す時、クエリ2で長い名前の子供が何回も呼ばれていたらTLEするのではないかと冷や冷やしていましたが、そうならなくてよかったです。

合格まで5分18秒、154/154点でした。

## [String Range Sort Query](https://techful-programming.com/user/event/session/4sps6Pyk/problem/coding/22110)

### 問題の概要

[ABC237G](https://atcoder.jp/contests/abc237/tasks/abc237_g)とほぼ同じです。

長い文字列 $S$ が与えられ、これに対する次のクエリを処理します。

- $1 l r$：$l$文字目から$r$文字目をソートする。
- $2 i$：$i$文字目を表示する。

### 感想

「String Range Sort Query」という問題名から「長い文字列が与えられ、区間ソートするクエリと表示するクエリが与えられるのだろうな」と推測したため、問題を開く前に回答をほぼ全部書いておきました。
残念ながらバグが存在したため1回で正答とはならず、残念です。

アルファベット26種類についてそれぞれカウントする遅延セグメント木を作ります。
演算はそれぞれの種類についての文字数の和、作用は文字の代入です。

ソートするときは、区間のそれぞれの文字種について個数を求め、順番に代入を作用させることで可能です。

合格まで提出2回、3分27秒、158/176点でした。
